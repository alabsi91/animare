import type { EaseFn } from '../types';

/**
 * Creates a spring easing function.
 *
 * ⚠️ **Warning** ⚠️ The spring easing function will only look smooth at certain durations and with certain parameters.
 *
 * @example
 * ```js
 * import animare, { ease } from 'animare';
 *
 * animare([
 * {
 *   name: 'anim',
 *   to: 100,
 *   ease: ease.spring({ mass: 1, stiffness: 100, damping: 10, velocity: 0, duration: 1000 })
 * }
 * ], onUpdate);
 * ```
 */
export function spring({ mass = 1, stiffness = 100, damping = 10, velocity = 0, duration = 1000 } = {}): EaseFn {
  const clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max);
  return (time: number) => {
    if (time === 0 || time === 1) return time;

    mass = clamp(mass, 0.1, 1000);
    stiffness = clamp(stiffness, 0.1, 1000);
    damping = clamp(damping, 0.1, 1000);
    velocity = clamp(velocity, 0.1, 1000);

    const w0 = Math.sqrt(stiffness / mass),
      zeta = damping / (2 * Math.sqrt(stiffness * mass)),
      wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0,
      a = 1,
      b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

    let progress = duration ? (duration * time) / 1000 : time;

    progress =
      zeta < 1
        ? Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress))
        : (a + b * progress) * Math.exp(-progress * w0);

    return 1 - progress;
  };
}

/**
 * Creates a staircase easing function.
 *
 * @param steps - The number of steps.
 * @param start - Whether to start at the beginning or at the end of each interval.
 *
 * @example
 * ```js
 * import animare, { ease } from 'animare';
 *
 * animare([{ name: 'anim', to: 100, ease: ease.steps(5) }], onUpdate);
 * ```
 */
export function steps(steps = 10, start = true): EaseFn {
  const clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max);
  const trunc = start ? Math.ceil : Math.floor;
  return (progress: number) => trunc(clamp(progress, 0, 1) * steps) / steps;
}

/**
 * Creates a custom easing function from an array of points.
 *
 * Use the [Animare Ease Visualizer](https://animare-ease-visualizer.netlify.app/) tool to create the easing function.
 *
 * **Syntax:** `ease.fromPoints(values: Float32List)`
 *
 * @example
 * ```js
 * import animare, { ease } from 'animare';
 * // Custom easing function generated by Animare Ease Visualizer tool
 * import myEase from './myEase.js';
 *
 * animare([{ name: 'anim', to: 100, ease: ease.fromPoints(myEase) }], onUpdate);
 * ```
 */
export function fromPoints(values: Float32List): EaseFn {
  if (!(values instanceof Float32Array) && !Array.isArray(values))
    throw new Error('\n\n⛔ [animare] ➡️ [ease] ➡️ [fromPoints] : first param must be an Array or Float32Array. !!\n\n');

  const length = values.length;

  return (t: number) => values[Math.floor(t * length)] ?? values[length - 1];
}

/**
 * Creates a simple elastic interaction, similar to a spring oscillating back and forth.
 *
 * The default bounciness is `1`, which overshoots a little bit once.
 * A bounciness of `0` doesn't overshoot at all,
 * and a bounciness of `N > 1` will overshoot about `N` times.
 */
export function wobble(bounciness = 1): EaseFn {
  const p = bounciness * Math.PI;
  return (t: number): number => 1 - Math.pow(Math.cos((t * Math.PI) / 2), 3) * Math.cos(t * p);
}

/** - **easeOutBounce:** check out [easings.net](https://easings.net/#easeOutBounce) to learn more.*/
export function bounce(t: number): number {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (t < 1 / d1) return n1 * t * t;
  if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
  if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
  return n1 * (t -= 2.625 / d1) * t + 0.984375;
}

/** Default linear easing function. */
export function linear(t: number) {
  return t;
}
